[
	{
		"summary": "Svelte",
		"content": "<p>I used sveltekit to create this portfolio website. I decided to go with sveltekit because of the server-side rendering (SSR) and all of the SEO features, as well as making the website really fast. The fact that this, to me, is less than an actual framework as it relies heavily on vanilla HTML, CSS, and JavaScript is what I'm looking for.</p><p>In comparing all of the frameworks for the best one to use, my list is 1.) Sveltekit 2.) Astro 3.) React. I like Astro because it is really easy to use, and you can use any other framework's components you want. I can use svelte with astro, react with astro, etc. I put react as #3 because it is really verbose.. but it does the same thing that sveltekit and astro do.</p>"
	},
	{
		"summary": "Basics",
		"content": "<p>I am very knowledgeable to the fundamentals of web development. CSS is a real hobby that I have because I'm a very visual person. Sveltekit has made it super simple to put my ideas on the web.</p><p>The framework is based off of html. Javascript is used in a script tag and css is used in a style tag just like you do in a html document. Everything is scoped, so the css inside of a component is the css for that component only.</p>"
	},
	{
		"summary": "Compiler?",
		"content": "<p>Svelte is a client based compiler that generates optimized javascript. Sveltekit is a framework that uses svelte under the hood. Think of how Nuxt is to Vue, or how Next is to React. In the end, sveltekit is a new approach to building rich user interfaces. Originally, svelte was created as a tool to build components for data visualization. It makes creating data visualizations super easy!</p><p>Svelte is usually used for SPA's (single page applications), but with sveltekit, you can use it's routing features to create a MPA's (multi-page applications). This is what I did with this website.</p>"
	},
	{
		"summary": "Install",
		"content": "<p>You need <a href=\"https://nodejs.org/\"><b>Node.js</b></a> installed. Once you have it installed, you will use npm in your terminal. In your terminal, type <code>cd folder</code> to change the directory to whatever folder you want to create your project in. If you're at where you want to be at, type <code>npx sv create</code>. This will create a new svelte project with sveltekit included. All of the dependencies will be installed when the project is created. Once you have the project installed, you will run <code>npm run dev</code> to start a development server and start the project. Now when you make changes to your code and press save, it will update on your development server automatically without having to hit refresh! Also, this starts the project on <code>http://localhost:5173</code>.</p><p>Once you have the development server running, you can start building your project. You can use the <code>src/routes</code> folder to create new pages. You can use the <code>src/lib</code> folder to store and create new components or data for your project.</p><p>You can use the <code>+layout.svelte</code> file to create a layout for your project. You can use the <code>+error.svelte</code> file to create an error page. And <code>+page.svelte</code> creates a new page.</p>"
	},
	{
		"summary": "Runes",
		"content": "<p>Runes are symbols that you use in .svelte and .svelte.js / .svelte.ts files to control the Svelte compiler. If you think of Svelte as a language, runes are part of the syntax â€” they are keywords.</p><p>Runes have a $ prefix and look like functions: <code>let message = $state('hello');</code>.</p><p>They differ from normal JavaScript functions in important ways, however:<br />ðŸ”¹ You don't need to import them â€” they are part of the language<br />ðŸ”¹ They're not values<br />ðŸ”¹ You can't assign them to a variable or pass them as arguments to a function - Just like JavaScript keywords, they are only valid in certain positions (the compiler will help you if you put them in the wrong place)</p><p>The state rune allows you to create reactive state, which means that your UI reacts when it changes: <code>let count = $state(0);</code></p><p>Derived state is declared with the $derived rune: <code>let doubled = $derived(count * 2);</code></p><p>Effects are what make your application do things. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside untrack), and re-runs the function when that state later changes.</p><p>You can also create your own effects with the $effect rune, which is useful for animating your website, especially with gsap!</p><div class=\"image-container\"><img src=\"https://cdn.jsdelivr.net/gh/gabrielatwell1987/portfolio-assets@main/images/effects_rune.webp\" alt=\"effect rune syntax with gsap\" loading=\"lazy\" style=\"aspect-ratio: 3/4; width: 100%; height: auto;\"></div><p>The inputs to a component are referred to as props, which is short for properties. You pass props to components just like you pass attributes to elements: <code>let { src, alt } = $props();</code></p><p>Destructuring allows us to declare fallback values, which are used if the parent component does not set a given prop: <code>let { alt = \"a wild one\" } = $props();</code></p><p>we can use a rest property to get, well, the rest of the props: <code>let { rest, props, ...fun } = $props();</code></p>"
	},
	{
		"summary": "Snippets",
		"content": "<p>Snippets allow you to reuse content within a component, without extracting it out into a separate file. Like function declarations, snippets can have an arbitrary number of parameters, which can have default values, and you can destructure each parameter. You cannot use rest parameters, however.</p><div class=\"responsive-image\"><img src=\"https://cdn.jsdelivr.net/gh/gabrielatwell1987/portfolio-assets@main/images/snippet.webp\" alt=\"snippet example in code\" loading=\"lazy\" style=\"aspect-ratio: 16/9; width: 100%; height: auto;\"></div><p>Snippets can be declared anywhere inside your component. They can reference values declared outside themselves, for example in the <code>&lt;script&gt;</code> tag or in <code>{#each ...}</code> blocks. They can also reference other snippets, but not themselves. Snippets are not reactive, so they will not re-run when the state changes. You can use them to create reusable components that are not reactive.</p>"
	},
	{
		"summary": "View Transitions",
		"content": "<p>If you have a sveltekit project and you've been trying to use view transitions and nothing is working, it's because sveltekit has a different way of doing things. In order to make the framework see the correct view transition api code, you need to add the following javascript code:</p><div class=\"responsive-image\"><img src=\"https://cdn.jsdelivr.net/gh/gabrielatwell1987/portfolio-assets@main/images/onNavigate.webp\" alt=\"onNavigate example in code\" loading=\"lazy\" style=\"aspect-ratio: 16/9; width: 100%; height: auto;\"></div><p>This makes your view transitions work for a sveltekit project! I have made a <code>&lt; ViewTransition /&gt;</code> component that you can use for your whole project by adding it in <code>+layout.svelte</code>.</p>"
	},
	{
		"summary": "derived(...)",
		"content": "<p>The expression inside of <code>$derived(...)</code> will re-run whenever any of the state or derived state it accesses changes. You can use <code>$derived(...)</code> to create derived state that depends on other pieces of state or derived state. The <code>derived(...)</code> expression should be free of side effects â€” it should only compute and return a value.<br>Code in Svelte components is only executed once at creation. Without the <code>$derived</code> rune, it will maintain its original value even when count changes.</p><div class=\"responsive-image\"><img src=\"https://cdn.jsdelivr.net/gh/gabrielatwell1987/portfolio-assets@main/images/derived.webp\" alt=\"derived example in code\" loading=\"lazy\" style=\"aspect-ratio: 16/9; width: 100%; height: auto;\"></div>"
	},
	{
		"summary": "derived.by(...)",
		"content": "<p>The <code>derived.by(...)</code> function allows you to create derived state that depends on other pieces of state or derived state, similar to <code>$derived(...)</code>. However, it provides a more explicit way to specify the dependencies of the derived state. The expression inside of <code>derived.by(...)</code> will re-run whenever any of the specified dependencies change.</p><div class=\"responsive-image\"><img src=\"https://cdn.jsdelivr.net/gh/gabrielatwell1987/portfolio-assets@main/images/derived-by.webp\" alt=\"derived.by example in code\" loading=\"lazy\" style=\"aspect-ratio: 16/9; width: 100%; height: auto;\"></div>"
	}
]